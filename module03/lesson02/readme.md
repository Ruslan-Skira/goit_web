# Процеси

*exitcode* -  Визначає, чи завершився процесс чи ні. None, якщо процес ще не завершено, 0 як, що добре.
## Process as Class
__02_process__as_class.py__

Одним із способів виконання коду в новому процесі є розширення класу *multiprocessing.Process.* Це забезпечує гнучкість і дозволяє зберігати дані як змінні екземпляра та отримувати до них доступ новому процесу.
Функцію *run()* класу *multiprocessing.Process* потрібно перевизначити, щоб вона містила код, який ви бажаєте виконати в іншому процесі.

Це також дозволяє групувати функції, пов’язані з новим процесом, з новим об’єктом.

Враховуючи те, що це спеціальний клас, ви можете визначити конструктор для класу та використовувати його для передачі даних, які можуть знадобитися у функції run(), збережених, наприклад, змінних екземплярів (атрибутів).

Ви також можете визначити додаткові функції в класі, щоб розділити роботу, яку вам може знадобитися виконати в іншому процесі.

## Join
__03_process__join.py__
 *Join* - метод блокується, доки процес, чий метод join() викликається, не завершиться.
 Ми можемо явно дочекатися завершення виконання нового процесу, викликавши функцію join().

## Lock
__04_process_lock_value_array.py__

*current_process* - Повертає об’єкт Process, що відповідає поточному процесу.
Аналог threading.current_thread()., RLock,
#### Value, Array
Атрибути екземпляру классу(процесс) можна спільно використовувати між процесами через класи multiprocessing.Value і multiprocessing.Array.

Ці класи явно визначають атрибути даних, призначені для спільного використання між процесами безпечним для процесу способом.

Спільні змінні означають, що зміни, зроблені в одному процесі, завжди поширюються та стають доступними для інших процесів.

**Value**

Конструктор класу multiprocessing.Value вимагає, щоб ми вказали тип даних і початкове значення.

Тип даних можна вказати за допомогою *[ctype](https://docs.python.org/uk/3/library/ctypes.html)* «type» або typecode.

Ми можемо визначити атрибут екземпляра як екземпляр multiprocessing.Value, який автоматично й правильно розподілятиметься між процесами.

## Event
__05_process_event.py__

Python надає об’єкт події(Event) для процесів(Process) через клас multiprocessing.Event.

Подія — це простий примітив паралелізму, який дозволяє спілкуватися між процесами.

Об’єкт multiprocessing.Event обгортає логічну змінну, яка може бути «встановлена» (True) або «не встановлена» (False). Процеси, які спільно використовують екземпляр події, можуть перевірити, чи встановлено подію, встановити подію, очистити подію (зробити її не встановленою) або дочекатися встановлення події.

Multiprocessing.Event забезпечує простий спосіб обміну логічної змінної між процесами, які можуть діяти як тригер для дії.

По-перше, необхідно створити об’єкт події, і подія буде в стані «не встановлено».

__06_event_stop.py__

Щось не зрозумілє.
### Event clear()
__07_event_restart.py__
Подію можна позначити як «не встановлено» (незалежно від того, встановлено вона наразі чи ні) за допомогою функції clear().

## Condition
__08_condition.py__

Умова дозволяє процесам чекати та отримувати сповіщення.
Ви можете використовувати об’єкт умови процесу в Python через клас *multiprocessing.Condition*.
Він поєднує в собі блокування взаємного виключення (мьютекс) і умовну змінну.

М'ютекс можна використовувати для захисту критичного розділу, але його не можна використовувати для сповіщення інших процесів про те, що умова змінилася або виконана.

Для того, щоб процес використовував умову, він повинен отримати її та звільнити, як блокування м’ютексу.
Це можна зробити вручну за допомогою функцій accept() і release(). Альтернативою безпосередньому виклику функцій accept() і release() є використання менеджера контексту, який автоматично виконає для нас отримання/вивільнення

## Semaphore Manager
__09_semaphore_manager.py__

*multiprocessing.Manager()*
Повертає запущений об’єкт SyncManager, який можна використовувати для спільного використання об’єктів між процесами. Повернений об’єкт менеджера відповідає породженому дочірньому процесу та має методи, які створюватимуть спільні об’єкти та повертатимуть відповідні проксі-сервери.
Процеси менеджера буде закрито, щойно відпрацює Garbadge Collector або їхній батьківський процес завершиться. Класи менеджерів визначені в модулі multiprocessing.managers:

*_Semaphore_* - це, по суті, лічильник,захищений мʼютекс блокуванням, який використовується для обмеження кількосіт процесів, які можуть отримати доступ до ресурсу.
Екземпляр *multiprocessing.Semaphore* має бути налаштований під час його створення, щоб встановити обмеження на внутрішньому лічильнику. Це обмеження відповідатиме кількості одночасних процесів, які можуть утримувати семафор.

## Barier
__10_barrier.py__
Бар'єр дозволяє координувати дочірні процеси.

Ви можете використовувати процесний бар’єр у Python через клас multiprocessing.Barrier.

Що таке бар'єр
Бар'єр - це примітив синхронізації.

Це дозволяє декільком процесам (або потокам) чекати на тому самому екземплярі об’єкта бар’єру (наприклад, в тій самій точці коду), доки не надійде заздалегідь визначена фіксована кількість процесів (наприклад, бар’єр буде заповнений), після чого всі процеси повідомляються та звільняються. продовжити їх виконання.

Внутрішньо бар’єр підтримує підрахунок кількості процесів, які очікують на бар’єрі, і налаштовану максимальну кількість учасників (процесів), які очікуються. Коли очікувана кількість сторін досягає попередньо визначеного максимуму, усі процеси, що очікують, повідомляються.

Це забезпечує корисний механізм для координації дій між кількома процесами.











Тут набір прикладів для процесів.
Можна буде показати для запитань по темі, що цікавить.
Вибрати й показати, що було не зрозуміло з конспекту.



Є практичні завдання:

- Папка `task-runner` - за допомогою процесів збираємо файли javascript в один файл
- Папка `file_sort` - Приклад сортування файлів за допомогою процесів. Аналог домашнього завдання
